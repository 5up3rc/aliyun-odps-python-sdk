# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2018, The Alibaba Group Holding Ltd.
# This file is distributed under the same license as the PyODPS package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PyODPS 0.7.16\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-05-17 10:48+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.3\n"

#: ../../source/ml-quickstart.rst:6
msgid "快速开始"
msgstr ""

#: ../../source/ml-quickstart.rst:8
msgid "开启 Jupyter Notebook，并新建一个记事本，创建一个 ODPS 对象："
msgstr ""

#: ../../source/ml-quickstart.rst:10
msgid ""
"from odps import ODPS\n"
"# ID、Key 等信息需要自行替换\n"
"o = ODPS(access_id, secret_access_key, project=project, endpoint=endpoint)"
msgstr ""

#: ../../source/ml-quickstart.rst:16
msgid "此后，创建一个范例数据集，使用 DataFrame 筛选一部分字段（注意不要遗漏标签），并查看数据的统计信息："
msgstr ""

#: ../../source/ml-quickstart.rst:29
msgid ""
">>> from odps.df.examples import create_ionosphere\n"
">>> df = create_ionosphere(o)['a01', 'a02', 'a03', 'a04', 'class']\n"
">>> df.describe()\n"
"    type    a01     a02     a03     a04     class\n"
"0   count   351.000000      351.0   351.000000      351.000000      "
"351.000000\n"
"1   mean    0.891738        0.0     0.641342        0.044372        "
"0.641026\n"
"2   std     0.311155        0.0     0.497708        0.441435        "
"0.480384\n"
"3   min     0.000000        0.0     -1.000000       -1.000000       "
"0.000000\n"
"4   max     1.000000        0.0     1.000000        1.000000        "
"1.000000"
msgstr ""

#: ../../source/ml-quickstart.rst:30
msgid "此后，对该数据集进行归一化，然后拆分并使用随机森林对训练集进行训练，查看输出的第一棵决策树："
msgstr ""

#: ../../source/ml-quickstart.rst:32
msgid ""
"from odps.ml.classifiers import *\n"
"# 归一化及拆分\n"
"train, test = df.min_max_scale(['a01', 'a02', 'a03', 'a04']).split(0.6)\n"
"# 使用训练集训练模型\n"
"model = RandomForests(tree_num=10).train(train)\n"
"# 载入森林中的第一棵决策树\n"
"result = model.execute()\n"
"result[0]"
msgstr ""

#: ../../source/ml-quickstart.rst:43
msgid ""
"如果逐条执行上述语句，会发现只有 execute 被调用时，所有代码才会执行。这是由于 PyODPS ML "
"采用了延迟执行的方式。关于这一方式的具体细节将在“延迟执行”一节中详述。 执行完成后，显示决策树如下："
msgstr ""

#: ../../source/ml-quickstart.rst:47
msgid ".. image:: _static/pyodps_output_decision_tree.svg"
msgstr ""

#: ../../source/ml-quickstart.rst:48
msgid "模型对象包含一个 predict 方法，可以对测试集进行预测。下面我们进行预测，将预测结果保存回 ODPS 并使用 DataFrame 进行统计："
msgstr ""

#: ../../source/ml-quickstart.rst:50
msgid ""
"# 对测试集进行预测\n"
"predicted = model.predict(test)\n"
"# 将结果保存到 test_out 表。这也是真正执行的步骤\n"
"predicted.persist('test_out')\n"
"# 使用 DataFrame 统计各个预测结果的个数\n"
"predicted.prediction_result.value_counts().to_pandas()"
msgstr ""

#: ../../source/ml-quickstart.rst:59
msgid "统计结果以表格显示："
msgstr ""

#: ../../source/ml-quickstart.rst:61
msgid ""
"<div>\n"
"<table border=\"1\" class=\"dataframe\" cellpadding=\"3\">\n"
"  <thead>\n"
"    <tr style=\"text-align: right;\">\n"
"      <th></th>\n"
"      <th>prediction_result</th>\n"
"      <th>count</th>\n"
"    </tr>\n"
"  </thead>\n"
"  <tbody>\n"
"    <tr>\n"
"      <th>0</th>\n"
"      <td>1</td>\n"
"      <td>101</td>\n"
"    </tr>\n"
"    <tr>\n"
"      <th>1</th>\n"
"      <td>0</td>\n"
"      <td>37</td>\n"
"    </tr>\n"
"  </tbody>\n"
"</table>\n"
"</div>"
msgstr ""

#: ../../source/ml-quickstart.rst:88
msgid "输出预测结果后，我们便可以计算预测结果的 ROC 曲线，并使用 matplotlib 进行绘制："
msgstr ""

#: ../../source/ml-quickstart.rst:90
msgid ""
"from odps.ml.metrics import roc_curve\n"
"import matplotlib.pyplot as plt\n"
"%matplotlib inline\n"
"\n"
"# roc_curve 将被立即执行\n"
"fpr, tpr, thresh = roc_curve(predicted)\n"
"plt.plot(fpr, tpr)"
msgstr ""

#: ../../source/ml-quickstart.rst:100
msgid "IPython 给出了绘制好的 ROC 曲线如下："
msgstr ""

#: ../../source/ml-quickstart.rst:103
msgid ".. image:: _static/pyodps_roc_output.png"
msgstr ""

#: ../../source/ml-quickstart.rst:104
msgid "pyodps/notebooks/ml_intro.ipynb 中给出了这个例子的 Notebook。"
msgstr ""

